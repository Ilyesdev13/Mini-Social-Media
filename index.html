<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Mini Social App</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">

<style>
* { box-sizing: border-box; }
body {
  margin: 0;
  font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
  background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
  color: white;
  min-height: 100vh;
}
.spinner {
  width: 50px;
  height: 50px;
  border: 5px solid rgba(255, 255, 255, 0.1);
  border-top: 5px solid white;
  border-radius: 50%;
  animation: spin 1s linear infinite;
}

@keyframes spin {
  0% { transform: rotate(0deg); }
  100% { transform: rotate(360deg); }
}

/* NAVBAR */
.navbar {
  position: fixed;
  top: 0;
  width: 100%;
  height: 60px;
  background: rgba(0, 0, 0, 0.3);
  backdrop-filter: blur(10px);
  display: flex;
  align-items: center;
  justify-content: space-between;
  padding: 0 20px;
  border-bottom: 1px solid rgba(255, 255, 255, 0.1);
  z-index: 100;
  box-shadow: 0 4px 30px rgba(0, 0, 0, 0.1);
}
.logo { 
  font-weight: 700;
  font-size: 20px;
  background: linear-gradient(135deg, #667eea, #764ba2);
  -webkit-background-clip: text;
  -webkit-text-fill-color: transparent;
  background-clip: text;
}
.navbar button {
  width: 40px;
  height: 40px;
  border-radius: 50%;
  font-size: 22px;
  background: linear-gradient(135deg, #667eea, #764ba2);
  border: none;
  color: white;
  cursor: pointer;
  transition: transform 0.2s, box-shadow 0.2s;
  box-shadow: 0 4px 15px rgba(102, 126, 234, 0.4);
  display: flex;
  align-items: center;
  justify-content: center;
  padding: 0;
}
.navbar button:hover { 
  transform: scale(1.1);
  box-shadow: 0 6px 20px rgba(102, 126, 234, 0.6);
}

/* AUTH & APP */
#auth, #app {
  max-width: 600px;
  margin: auto;
  padding: 20px;
}
#app { margin-top: 80px; padding-bottom: 40px; }

input, textarea {
  width: 100%;
  padding: 12px 16px;
  background: rgba(255, 255, 255, 0.1);
  color: white;
  border: 1px solid rgba(255, 255, 255, 0.2);
  border-radius: 12px;
  backdrop-filter: blur(10px);
  font-family: inherit;
  font-size: 16px;
  transition: all 0.3s ease;
}
input:focus, textarea:focus {
  outline: none;
  background: rgba(255, 255, 255, 0.15);
  border-color: rgba(255, 255, 255, 0.4);
  box-shadow: 0 0 20px rgba(102, 126, 234, 0.3);
}
input::placeholder, textarea::placeholder {
  color: rgba(255, 255, 255, 0.6);
}

button {
  background: linear-gradient(135deg, #667eea, #764ba2);
  border: none;
  padding: 10px 20px;
  border-radius: 10px;
  color: white;
  cursor: pointer;
  font-weight: 600;
  transition: all 0.3s ease;
  box-shadow: 0 4px 15px rgba(102, 126, 234, 0.4);
}
.story-preview-box {
  margin: 10px 0;
  height: 300px; /* Increased from 180px */
  border-radius: 12px;
  background: rgba(0,0,0,0.3);
  display: flex;
  align-items: center;
  justify-content: center;
  overflow: hidden;
}
/* Update these in your <style> tag */
#storyViewer {
  display: none;
  position: fixed;
  inset: 0;
  background: #000; /* Pure black background for stories */
  z-index: 1000;
  flex-direction: column;
  align-items: center;
  justify-content: center;
}

/* üî• FULL SCREEN STORY FIX */
#storyViewMedia {
  width: 100vw;       /* Full viewport width */
  height: 100vh;      /* Full viewport height */
  max-width: 500px;   /* Limits width on desktop so it doesn't look stretched */
  margin: 0 auto;
  display: flex;
  align-items: center;
  justify-content: center;
  background: #000;   /* Black background for letterboxing */
  position: relative;
  overflow: hidden;
}

#storyViewMedia img {
  width: 100%;        /* Force image to fill width */
  height: 100%;       /* Force image to fill height */
  object-fit: contain; /* OR use 'cover' if you want it to fill the whole screen (but it might crop) */
  display: block;
}

.story-preview-box img {
  max-width: 100%;
  max-height: 100%;
  object-fit: contain; /* Shows full image in preview */
  display: none; /* Changed to block via JS when image loads */
}

.story-preview-box span {
  color: #777;
  font-size: 14px;
}

button:hover { 
  transform: translateY(-2px);
  box-shadow: 0 6px 25px rgba(102, 126, 234, 0.6);
}
button:active {
  transform: translateY(0);
}

/* POSTS */
.post {
  background: rgba(255, 255, 255, 0.1);
  backdrop-filter: blur(10px);
  padding: 20px;
  border-radius: 16px;
  margin-top: 20px;
  border: 1px solid rgba(255, 255, 255, 0.2);
  transition: all 0.3s ease;
  box-shadow: 0 4px 30px rgba(0, 0, 0, 0.1);
}
.post:hover {
  background: rgba(255, 255, 255, 0.15);
  transform: translateY(-4px);
  box-shadow: 0 8px 40px rgba(0, 0, 0, 0.2);
}
/* Find this in your <style> tag and update it */
.post img {
  width: 100%;
  max-height: 400px; /* Adjust this number to your liking */
  border-radius: 12px;
  margin-top: 12px;
  object-fit: contain; /* This keeps the full image visible without cropping */
  background: rgba(0,0,0,0.2); /* Adds a slight background for transparent images */
}
.actions {
  display: flex;
  gap: 20px;
  margin-top: 15px;
  cursor: pointer;
  font-size: 14px;
}
.actions span {
  transition: color 0.2s;
  opacity: 0.7;
}
.actions span:hover {
  opacity: 1;
}
.comment {
  font-size: 14px;
  margin-top: 8px;
  color: rgba(255, 255, 255, 0.7);
}

/* MODAL */
.modal {
  display: none;
  position: fixed;
  inset: 0;
  background: rgba(0, 0, 0, 0.6);
  backdrop-filter: blur(5px);
  align-items: center;
  justify-content: center;
  z-index: 200;
}
.modal-content {
  background: rgba(0, 0, 0, 0.3);
  backdrop-filter: blur(20px);
  padding: 30px;
  width: 90%;
  max-width: 450px;
  border-radius: 20px;
  border: 1px solid rgba(255, 255, 255, 0.2);
  box-shadow: 0 8px 40px rgba(0, 0, 0, 0.3);
  animation: slideUp 0.3s ease-out;
  max-height: 90vh;
  overflow-y: auto;
}
@keyframes slideUp {
  from {
    opacity: 0;
    transform: translateY(20px);
  }
  to {
    opacity: 1;
    transform: translateY(0);
  }
}
.modal-content h3 {
  margin-top: 0;
  font-size: 22px;
}
.modal-content button {
  width: 100%;
  margin-top: 12px;
}
.modal-content button:last-of-type {
  background: rgba(255, 255, 255, 0.1);
  border: 1px solid rgba(255, 255, 255, 0.2);
}

/* MAIN APP LAYOUT */
#app {
  display: none;
  max-width: 1400px !important;
  margin: 0 auto !important;
  margin-top: 80px !important;
  padding: 0 !important;
  display: grid;
  grid-template-columns: 300px 1fr;
  gap: 20px;
  height: calc(100vh - 100px);
}
/* =================== */
/* VOICE MESSAGES STYLING */
/* =================== */

/* Voice message container */
.voice-message-container {
  padding: 12px 16px;
  border-radius: 20px;
  margin: 8px 0;
  max-width: 70%;
  backdrop-filter: blur(10px);
  border: 1px solid rgba(255, 255, 255, 0.3);
  position: relative;
}

/* Own voice messages (sent by current user) */
.message.own .voice-message-container {
  background: linear-gradient(135deg, #667eea, #764ba2);
  margin-left: auto;
  border-bottom-right-radius: 5px;
  box-shadow: 0 4px 15px rgba(102, 126, 234, 0.4);
}

/* Other voice messages (received) */
.message.other .voice-message-container {
  background: rgba(255, 255, 255, 0.15);
  margin-right: auto;
  border-bottom-left-radius: 5px;
  box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
}

/* Voice badge (for visual indicator) */
.voice-badge {
  display: inline-flex;
  align-items: center;
  gap: 6px;
  margin-bottom: 8px;
  font-size: 12px;
  opacity: 0.8;
}

.voice-badge::before {
  content: "üé§";
  font-size: 14px;
}

/* Audio player styling - Modern look */
.voice-message-player {
  width: 100% !important;
  min-width: 250px;
  height: 45px !important;
  border-radius: 25px !important;
  background: rgba(0, 0, 0, 0.3) !important;
  border: 2px solid rgba(255, 255, 255, 0.2) !important;
  outline: none !important;
  transition: all 0.3s ease !important;
  padding: 0 10px !important;
}

.voice-message-player:hover {
  background: rgba(0, 0, 0, 0.4) !important;
  border-color: rgba(255, 255, 255, 0.3) !important;
  box-shadow: 0 5px 20px rgba(0, 0, 0, 0.2) !important;
}

/* Customize webkit audio controls */
.voice-message-player::-webkit-media-controls-panel {
  background: transparent !important;
  border-radius: 20px !important;
  padding: 0 5px !important;
}
/* PROFILE GRID */
.public-posts-grid {
  display: grid;
  grid-template-columns: repeat(3, 1fr);
  gap: 8px;
}

/* PROFILE CARD */
.profile-post {
  position: relative;
  aspect-ratio: 1 / 1;
  border-radius: 12px;
  overflow: hidden;
  background: #111;
  color: #fff;
  cursor: pointer;
}

/* TEXT */
.profile-post-text {
  position: absolute;
  inset: 0;
  z-index: 5;
  display: flex;
  align-items: center;
  justify-content: center;
  text-align: center;
  padding: 12px;
  font-size: 13px;
  line-height: 1.4;
  opacity: 1;
  transition: opacity 0.25s ease;
}

/* IMAGE */
.profile-post-img {
  position: absolute;
  inset: 0;
  z-index: 1;
  opacity: 0;
  transition: opacity 0.25s ease;
}

.profile-post-img img {
  width: 100%;
  height: 100%;
  object-fit: cover;
  display: block; /* IMPORTANT */
}

/* ACTIVE */
.profile-post.show-image .profile-post-text {
  opacity: 0;
}

.profile-post.show-image .profile-post-img {
  opacity: 1;
}



.voice-message-player::-webkit-media-controls-play-button {
  background-color: #667eea !important;
  border-radius: 50% !important;
  margin-right: 10px !important;
}

.voice-message-player::-webkit-media-controls-volume-slider-container,
.voice-message-player::-webkit-media-controls-volume-slider {
  background-color: #667eea !important;
  border-radius: 10px !important;
}

.voice-message-player::-webkit-media-controls-current-time-display,
.voice-message-player::-webkit-media-controls-time-remaining-display {
  color: white !important;
  font-size: 12px !important;
  text-shadow: 0 1px 2px rgba(0, 0, 0, 0.5) !important;
}

.voice-message-player::-webkit-media-controls-timeline {
  background-color: rgba(255, 255, 255, 0.2) !important;
  border-radius: 10px !important;
  height: 4px !important;
  margin: 0 10px !important;
}

.voice-message-player::-webkit-media-controls-timeline-progress-bar {
  background: linear-gradient(90deg, #667eea, #764ba2) !important;
  border-radius: 10px !important;
}

/* Comments voice messages */
.comment .voice-message-container {
  max-width: 90%;
  margin: 8px 0;
}

.comment .voice-message-player {
  min-width: 200px;
  height: 40px !important;
}

/* Voice recording UI */
.voice-recording-ui {
  display: flex;
  flex-direction: column;
  gap: 10px;
  padding: 15px;
  background: rgba(0, 0, 0, 0.3);
  border-radius: 15px;
  margin: 10px 0;
  border: 2px solid rgba(245, 87, 108, 0.3);
  animation: pulseBorder 2s infinite;
}

@keyframes pulseBorder {
  0%, 100% { border-color: rgba(245, 87, 108, 0.3); }
  50% { border-color: rgba(245, 87, 108, 0.6); }
}

.recording-time {
  font-family: monospace;
  font-size: 24px;
  font-weight: bold;
  text-align: center;
  color: #ff4757;
  text-shadow: 0 0 10px rgba(255, 71, 87, 0.5);
}

.recording-controls {
  display: flex;
  gap: 10px;
}

.recording-controls button {
  flex: 1;
  padding: 12px !important;
  font-weight: bold;
  display: flex;
  align-items: center;
  justify-content: center;
  gap: 8px;
}
/* STORY BAR */
.stories-bar {
  display: flex;
  gap: 14px;
  padding: 10px 0;
  overflow-x: auto;
}

.story-circle {
  width: 72px;
  text-align: center;
  cursor: pointer;
  flex-shrink: 0;
}
/* üî• STORY VIEWER IMAGE FIX */
#storyViewMedia {
  width: 100%;
  height: 100%;
  display: flex;
  align-items: center;
  justify-content: center;
  background: #000; /* Black bars for images that don't fit perfectly */
  border-radius: 16px;
  overflow: hidden;
}

#storyViewMedia img {
  max-width: 100%;
  max-height: 100%;
  width: auto;
  height: auto;
  object-fit: contain; /* This prevents the "cropping" error */
  display: block;
}
.story-circle-inner {
  width: 64px;
  height: 64px;
  padding: 3px;
  border-radius: 50%;
  background: linear-gradient(45deg, #ff005d, #ffb400);
  display: flex;
  align-items: center;
  justify-content: center;
  margin: auto;
  transition: transform 0.2s;
}

.story-circle-inner:hover {
  transform: scale(1.05);
}

.story-circle-inner img {
  width: 100%;
  height: 100%;
  border-radius: 50%;
  object-fit: cover;
  background: #000;
}

.story-circle span {
  font-size: 12px;
  margin-top: 5px;
  display: block;
  opacity: 0.9;
}


.stop-recording {
  background: linear-gradient(135deg, #ff4757, #ff6b81) !important;
}

.send-recording {
  background: linear-gradient(135deg, #2ed573, #1dd1a1) !important;
}

/* Audio loading indicator */
.audio-loading {
  display: flex;
  align-items: center;
  justify-content: center;
  padding: 20px;
}

.audio-loading::after {
  content: "";
  width: 30px;
  height: 30px;
  border: 3px solid rgba(255, 255, 255, 0.1);
  border-top: 3px solid #667eea;
  border-radius: 50%;
  animation: spin 1s linear infinite;
}

@keyframes spin {
  0% { transform: rotate(0deg); }
  100% { transform: rotate(360deg); }
}

/* Voice message duration indicator */
.voice-duration {
  font-size: 11px;
  opacity: 0.7;
  margin-top: 5px;
  text-align: right;
  font-style: italic;
}

/* Mobile optimization for audio */
@media (max-width: 768px) {
  .voice-message-container {
    max-width: 85%;
    color: black;
  }
  
  .voice-message-player {
    min-width: 200px;
    height: 40px !important;
  }
  
  .comment .voice-message-player {
    min-width: 150px;
    height: 35px !important;
  }
  
  .voice-recording-ui {
    padding: 12px;
  }
  
  .recording-time {
    font-size: 20px;
  }
}

/* Fallback for non-webkit browsers */
audio.voice-message-player:not(:-webkit-media-controls-panel) {
  background: rgba(0, 0, 0, 0.3) !important;
  border-radius: 25px !important;
  padding: 5px !important;
}

/* Voice message in notifications/small contexts */
.small-voice-player {
  width: 100%;
  height: 30px !important;
  border-radius: 15px !important;
  background: rgba(0, 0, 0, 0.2) !important;
  border: 1px solid rgba(255, 255, 255, 0.1) !important;
}
.app-sidebar {
  background: rgba(255, 255, 255, 0.1);
  backdrop-filter: blur(10px);
  border-radius: 16px;
  padding: 20px;
  border: 1px solid rgba(255, 255, 255, 0.2);
  overflow-y: auto;
  display: flex;
  flex-direction: column;
}

.app-main {
  display: flex;
  flex-direction: column;
  gap: 20px;
}

.feed-section, .chat-section {
  background: rgba(255, 255, 255, 0.1);
  backdrop-filter: blur(10px);
  border-radius: 16px;
  padding: 20px;
  border: 1px solid rgba(255, 255, 255, 0.2);
  overflow-y: auto;
  flex: 1;
}

.sidebar-title {
  font-size: 16px;
  font-weight: 700;
  margin-bottom: 15px;
  text-transform: uppercase;
  letter-spacing: 1px;
  opacity: 0.8;
}

/* AUDIO PLAYER STYLING */
audio.voice-message-player {
  width: 100%;
  max-width: 300px;
  height: 40px;
  border-radius: 8px;
  background: linear-gradient(135deg, rgba(102, 126, 234, 0.2), rgba(118, 75, 162, 0.2));
  accent-color: #667eea;
  outline: none;
}

audio.voice-message-player::-webkit-media-controls-panel {
  background: linear-gradient(135deg, rgba(102, 126, 234, 0.25), rgba(118, 75, 162, 0.25));
  border-radius: 8px;
}

audio.voice-message-player::-webkit-media-controls-mute-button {
  accent-color: #667eea;
}

audio.voice-message-player::-webkit-media-controls-play-button {
  accent-color: #667eea;
}

audio.voice-message-player::-webkit-media-controls-timeline {
  accent-color: #667eea;
}


.friend-item {
  background: rgba(255, 255, 255, 0.1);
  padding: 12px;
  border-radius: 10px;
  margin-bottom: 8px;
  cursor: pointer;
  transition: all 0.2s;
  border: 1px solid transparent;
}

.friend-item:hover {
  background: rgba(255, 255, 255, 0.15);
  transform: translateX(4px);
}

.friend-item.active {
  background: linear-gradient(135deg, #667eea, #764ba2);
  border-color: rgba(255, 255, 255, 0.3);
}

.add-friend-btn {
  width: 100%;
  margin-bottom: 15px;
}

.chat-container {
  display: flex;
  flex-direction: column;
  gap: 10px;
}

.chat-messages {
  flex: 1;
  overflow-y: auto;
  margin-bottom: 15px;
  display: flex;
  flex-direction: column;
  gap: 8px;
}

.message {
  padding: 12px 15px;
  border-radius: 12px;
  word-wrap: break-word;
  font-size: 14px;
}

.message.own {
  background: linear-gradient(135deg, #667eea, #764ba2);
  margin-left: 30px;
  border-bottom-right-radius: 4px;
}

.message.other {
  background: rgba(255, 255, 255, 0.2);
  margin-right: 30px;
  border-bottom-left-radius: 4px;
}

.voice-message-chat {
  width: 200px;
  max-width: 100%;
}

/* BETTER AUDIO PLAYER */
audio {
  accent-color: #667eea;
  filter: brightness(1.2);
}

.chat-input-group {
  display: flex;
  gap: 10px;
}

.chat-input-group input {
  flex: 1;
  margin: 0;
}

.chat-input-group button {
  padding: 10px 20px;
  margin: 0;
}

.no-chat {
  display: flex;
  align-items: center;
  justify-content: center;
  height: 100%;
  color: rgba(255, 255, 255, 0.5);
  text-align: center;
}
.story-nav {
  position: absolute;
  top: 50%;
  transform: translateY(-50%);
  background: rgba(0,0,0,0.35);
  color: white;
  border: none;
  font-size: 30px;
  padding: 12px 16px;
  cursor: pointer;
  z-index: 1000;
  border-radius: 50%;
}

.story-nav.left {
  left: 15px;
}

.story-nav.right {
  right: 15px;
}


/* COMMENTS */
.comments-section {
  margin-top: 15px;
  padding-top: 15px;
  border-top: 1px solid rgba(255, 255, 255, 0.2);
}
.group-item {
  background: rgba(102, 126, 234, 0.2);
  padding: 10px;
  border-radius: 10px;
  margin-bottom: 8px;
  cursor: pointer;
}

.comment-item {
  background: rgba(0, 0, 0, 0.2);
  padding: 10px 12px;
  border-radius: 8px;
  margin-bottom: 8px;
  font-size: 13px;
}

.comment-author {
  font-weight: 600;
  margin-bottom: 4px;
}

.comment-text {
  color: rgba(255, 255, 255, 0.9);
}

.comment-input-group {
  display: flex;
  gap: 8px;
  margin-top: 10px;
}

.comment-input-group input {
  flex: 1;
  padding: 8px 12px !important;
  margin: 0 !important;
  font-size: 13px;
}

.comment-input-group button {
  padding: 8px 12px !important;
  margin: 0 !important;
  width: auto;
  font-size: 13px;
}

/* VOICE RECORDING */
.voice-btn {
  padding: 10px 20px;
  background: linear-gradient(135deg, #f093fb, #f5576c);
  border: none;
  border-radius: 10px;
  color: rgb(0, 0, 0);
  cursor: pointer;
  font-weight: 600;
  transition: all 0.3s ease;
  box-shadow: 0 4px 15px rgba(245, 87, 108, 0.4);
}

.voice-btn:hover {
  transform: translateY(-2px);
  box-shadow: 0 6px 25px rgba(245, 87, 108, 0.6);
}

.voice-btn.recording {
  background: #ff4757;
  animation: pulse 1s infinite;
}

@keyframes pulse {
  0%, 100% { transform: scale(1); }
  50% { transform: scale(1.05); }
}

.audio-message {
  background: linear-gradient(135deg, #f093fb, #f5576c);
  padding: 12px;
  border-radius: 10px;
  margin-bottom: 8px;
}

.audio-message audio {
  width: 100%;
  height: 30px;
  border-radius: 6px;
}

@media (max-width: 1000px) {
  #app {
    grid-template-columns: 1fr;
  }
  
  .app-sidebar {
    max-height: 200px;
  }
}
</style>
</head>

<body>
  <div id="globalLoader" style="
    position: fixed; 
    inset: 0; 
    background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); 
    z-index: 9999; 
    display: flex; 
    flex-direction: column; 
    align-items: center; 
    justify-content: center;">
    
    <div class="spinner"></div>
    <h2 style="margin-top: 20px; font-weight: 400; letter-spacing: 2px;">LOADING APP...</h2>
</div>
<div id="postModal" class="modal">
  <div class="modal-content">
    <h3>Create Post</h3>



    <textarea id="postText" placeholder="What's on your mind?"></textarea>

    <input id="mediaUrl" placeholder="Image url">

    <div id="mediaPreview" style="margin-top:10px; display:none;"></div>

    <button id="postBtn">Post</button>
    <button id="closePostModal" style="background:#333;">Cancel</button>
  </div>
</div>



<header class="navbar" id="navbar" style="display:none;">
  <span class="logo">MiniSocial</span>
  <div style="display: flex; gap: 15px; align-items: center;">
    <button id="feedBtn" title="Feed" style="font-size: 20px; opacity: 1;">üè†</button>
    <button id="messagesBtn" title="Messages" style="font-size: 20px; opacity: 0.6;">üí¨</button>
    <button id="notificationsBtn" title="Notifications" style="font-size: 20px; opacity: 0.6; position: relative;">üîî<span id="notificationBadge" style="position: absolute; top: -5px; right: -5px; background: #ff4757; color: white; border-radius: 50%; width: 20px; height: 20px; display: flex; align-items: center; justify-content: center; font-size: 12px; display: none;">0</span></button>
    <button id="openProfileModal" title="Profile" style="font-size: 20px;">üë§</button>
    <button id="openPostModal" style="font-size: 20px;">‚ûï</button>
  </div>
</header>

<div id="auth">
  <h3>Login / Register</h3>
  <input id="email" placeholder="Email">
  <br><br>
  <input id="password" type="password" placeholder="Password">
  <br><br>
  <button id="loginBtn">Login</button>
  <button id="registerBtn">Register</button>
  <p id="authMsg"></p>
</div>
<div id="publicProfileModal" class="modal">
  <div class="modal-content" style="max-width: 500px;">
    <div style="text-align: center; margin-bottom: 20px;">
      <div id="publicProfilePic" style="width: 100px; height: 100px; margin: 0 auto 15px; border-radius: 50%; background: linear-gradient(135deg, #667eea, #764ba2); display: flex; align-items: center; justify-content: center; font-size: 40px; overflow: hidden;">üë§</div>
      <h3 id="publicProfileEmail" style="margin: 0;">User Email</h3>
    </div>
    
    <div style="background: rgba(255,255,255,0.1); padding: 15px; border-radius: 10px; margin-bottom: 15px;">
      <p><strong>Bio:</strong></p>
      <p id="publicProfileBio" style="font-style: italic; opacity: 0.9;">No bio available.</p>
    </div>

    <div style="border-top: 1px solid rgba(255,255,255,0.2); padding-top: 15px;">
      <h4 style="margin-bottom: 15px;">User Posts</h4>
      <p>click to see image</p>
      <div id="publicProfilePosts" style="max-height: 300px; overflow-y: auto;">
        </div>
    </div>
    
    <button id="closePublicProfile" style="background:#333; margin-top: 15px;">Close</button>
  </div>
</div>
<div id="app" style="display:none;">
  <!-- SIDEBAR -->
  <div class="app-sidebar">
    <div>
      <p id="userInfo" style="margin-bottom: 15px;"></p>
      <button id="logoutBtn" style="width: 100%; margin-bottom: 20px;">Logout</button>
    </div>
    
    <div style="flex: 1;">
      <div class="sidebar-title">Friends</div>
      <button class="add-friend-btn" id="openAddFriendModal">‚ûï Add Friend</button>
      <div id="friendsList"></div>
    </div>
  </div>
  
  <!-- MAIN CONTENT -->
 <div class="app-main">
    <div class="feed-section" id="feedSection">
        <div class="stories-container" id="storiesContainer" style="display: flex; gap: 10px; overflow-x: auto; padding-bottom: 15px; margin-bottom: 20px; border-bottom: 1px solid rgba(255,255,255,0.1);">
            <div id="addStoryBtn" style="min-width: 70px; height: 70px; border-radius: 50%; background: rgba(255,255,255,0.2); display: flex; align-items: center; justify-content: center; cursor: pointer; border: 2px dashed rgba(255,255,255,0.5);">‚ûï</div>
            <div id="storiesList" style="display: flex; gap: 10px;"></div>
        </div>

        <div id="groupModal" class="modal">
            <div class="modal-content">
                <h3>Create Group Chat</h3>
                <input id="groupName" placeholder="Group Name">
                <div id="memberSelection" style="max-height: 150px; overflow-y: auto; margin: 10px 0; border: 1px solid rgba(255,255,255,0.2); padding: 5px; border-radius: 8px;">
                </div>
                <button id="createGroupBtn">Create Group</button>
                <button id="closeGroupModal" style="background:#333;">Cancel</button>
            </div>
        </div>
        
        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px;">
            <h3 style="margin: 0;">Feed</h3>
        </div>
        <div id="feed"></div>
    </div>
    
    <div class="chat-section" id="chatSection" style="display: none;">
        <h3 style="margin: 0 0 15px 0;">Messages</h3>
        <div class="no-chat" id="noChatMessage">
            <p>Select a friend to chat</p>
        </div>
        <div id="chatContainer" style="display: none; flex-direction: column; height: 100%;">
            <div style="font-weight: 600; margin-bottom: 15px; padding-bottom: 10px; border-bottom: 1px solid rgba(255,255,255,0.2);" id="chatHeader"></div>
            <div class="chat-messages" id="chatMessages"></div>
            <div style="display: none; margin-top: 10px; padding: 15px; background: rgba(255,255,255,0.1); border-radius: 10px; text-align: center;" id="voiceChatRecordingUI">
                <p style="margin-bottom: 10px; font-weight: 600;" id="chatRecordingTime">00:00</p>
                <div style="display: flex; gap: 10px;">
                    <button id="stopVoiceChatBtn" style="flex: 1; background: #ff4757; border: none; border-radius: 10px; color: white; cursor: pointer; font-weight: 600; padding: 10px;">‚èπ Stop</button>
                    <button id="sendVoiceChatBtn" style="flex: 1; background: linear-gradient(135deg, #f093fb, #f5576c); border: none; border-radius: 10px; color: white; cursor: pointer; font-weight: 600; padding: 10px;">üì§ Send</button>
                </div>
            </div>
            <div class="chat-input-group">
                <input id="messageInput" placeholder="Type a message..." style="margin: 0;">
                <button id="sendMessageBtn" style="padding: 10px 20px; margin: 0; width: auto;">Send</button>
                <button id="recordVoiceChatBtn" class="voice-btn" style="padding: 10px 20px; margin: 0; width: auto; background: linear-gradient(135deg, #f093fb, #f5576c);">üé§</button>
            </div>
        </div>
    </div>
    
    <div class="chat-section" id="notificationsSection" style="display: none;">
        <h3 style="margin: 0 0 15px 0;">Friend Requests</h3>
        <div id="notificationsList"></div>
    </div>
</div>

<!-- STORY MODAL -->
<div id="storyModal" class="modal">
  <div class="modal-content">
    <h3>Create story</h3>


    <input id="storyImageUrl" placeholder="Story image URL">

    <div class="story-preview-box">
      <img id="storyPreview" />
      <span id="storyPreviewText">Preview</span>
    </div>

    <button id="storyPostBtn">Post Story</button>
    <button id="closeStoryModal" style="background:#333;">Cancel</button>
  </div>
</div>


<!-- ADD FRIEND MODAL -->
<div id="addFriendModal" class="modal">
  <div class="modal-content">
    <h3>Add Friend</h3>
    <input id="friendEmail" placeholder="Friend's email">
    <button id="addFriendBtn">Add Friend</button>
    <button id="closeAddFriendModal" style="background:#333;">Cancel</button>
    <p id="addFriendMsg" style="text-align: center; color: #ccc;"></p>
  </div>
</div>

<!-- PROFILE MODAL -->
<div id="profileModal" class="modal">
  <div class="modal-content">
    <h3>My Profile</h3>
    <div style="text-align: center; margin-bottom: 20px;">
      <div style="width: 100px; height: 100px; margin: 0 auto 15px; border-radius: 50%; background: linear-gradient(135deg, #667eea, #764ba2); display: flex; align-items: center; justify-content: center; font-size: 40px; cursor: pointer; overflow: hidden;" id="profilePicDisplay">
        üì∑
      </div>
      <input type="file" id="profilePicInput" accept="image/*" style="display: none;">
      <button id="uploadProfilePicBtn" style="width: 100%;">üì∏ Change Picture</button>
    </div>

    <div style="background: rgba(255,255,255,0.1); padding: 15px; border-radius: 10px; margin-bottom: 15px;">
      <p><strong>Email:</strong> <span id="profileEmail"></span></p>
      
      <div style="margin-top: 15px;">
        <label style="display: block; margin-bottom: 5px; font-weight: 600; font-size: 14px; opacity: 0.8;">About Me:</label>
        <textarea id="profileBioInput" placeholder="Tell us about yourself..." style="height: 80px; font-size: 14px; margin-bottom: 10px;"></textarea>
        <button id="saveBioBtn" style="width: 100%; background: #2ed573; font-size: 14px;">Save Bio</button>
      </div>

      <p style="margin-top: 15px;"><strong>Friends:</strong> <span id="profileFriendCount">0</span></p>
    </div>
    <button id="closeProfileModal" style="background:#333; width: 100%;">Close</button>
  </div>
</div>

<!-- NAVBAR PROFILE PIC -->
<div style="position: fixed; top: 12px; left: 12px; z-index: 90; width: 40px; height: 40px; border-radius: 50%; background: linear-gradient(135deg, #667eea, #764ba2); display: flex; align-items: center; justify-content: center; font-size: 20px; cursor: pointer; overflow: hidden; border: 2px solid rgba(255,255,255,0.3);" id="navbarProfilePic">üë§</div>

<!-- COMMENTS MODAL -->
<div id="commentsModal" class="modal">
  <div class="modal-content" style="max-width: 500px;">
    <h3>Comments</h3>
    <div id="commentsList" style="max-height: 300px; overflow-y: auto; margin-bottom: 20px; border-bottom: 1px solid rgba(255,255,255,0.2); padding-bottom: 15px;"></div>
    <div style="display: flex; gap: 10px; margin-bottom: 15px;">
      <input id="commentInput" placeholder="Write a comment..." style="flex: 1; margin: 0;">
      <button id="postCommentBtn" style="width: auto; padding: 10px 20px; margin: 0;">Post</button>
    </div>
    <div style="display: flex; gap: 10px;">
      <button id="startVoiceBtn" class="voice-btn" style="flex: 1;">üé§ Record Voice</button>
      <button id="closeCommentsModal" style="flex: 1; background: rgba(255,255,255,0.1); border: 1px solid rgba(255,255,255,0.2); border-radius: 10px; color: white; cursor: pointer; font-weight: 600; padding: 10px;">Close</button>
    </div>
    <div id="voiceRecordingUI" style="display: none; margin-top: 15px; padding: 15px; background: rgba(255,255,255,0.1); border-radius: 10px;">
      <p style="margin-bottom: 10px; text-align: center; font-weight: 600;" id="recordingTime">00:00</p>
      <div style="display: flex; gap: 10px;">
        <button id="stopVoiceBtn" style="flex: 1; background: #ff4757; border: none; border-radius: 10px; color: white; cursor: pointer; font-weight: 600; padding: 10px;">‚èπ Stop</button>
        <button id="sendVoiceBtn" style="flex: 1; background: linear-gradient(135deg, #f093fb, #f5576c); border: none; border-radius: 10px; color: white; cursor: pointer; font-weight: 600; padding: 10px;">üì§ Send</button>
      </div>
    </div>
  </div>
</div>
<div id="storyViewer" class="modal" style="background: rgba(0,0,0,0.95); z-index: 3000; display:none; flex-direction:column; align-items:center; justify-content:center;">
  <div class="story-nav left" onclick="prevStory()">‚Äπ</div>
    <div class="story-nav right" onclick="nextStory()">‚Ä∫</div>
  <div style="position: absolute; top: 10px; left: 0; width: 100%; height: 4px; display: flex; gap: 5px; padding: 0 10px;">
    <div id="storyProgress" style="height: 100%; background: white; width: 0%; transition: width 0.1s linear;"></div>
  </div>
  
  <div style="width: 100%; max-width: 450px; position: relative; padding: 20px;">
    <div style="display: flex; align-items: center; gap: 10px; margin-bottom: 15px;">
      <img id="storyViewAvatar" src="" style="width: 40px; height: 40px; border-radius: 50%; border: 2px solid white; object-fit: cover;">
      <span id="storyViewUser" style="font-weight: bold; font-size: 1.1rem; text-shadow: 2px 2px 4px rgba(0,0,0,0.5);"></span>
      <span id="closeStory" style="margin-left: auto; cursor: pointer; font-size: 32px;">&times;</span>
    </div>

    <div id="storyViewMedia"
     style="width:100%; max-height:70vh; border-radius:12px; overflow:hidden;
            box-shadow:0 10px 30px rgba(0,0,0,0.5);">
</div>


    <div style="display: flex; flex-direction: column; align-items: center; justify-content: center; margin-top: 25px; gap: 8px;">
      <button id="likeStoryBtn" style="background: rgba(255,255,255,0.1); border: 2px solid white; border-radius: 50%; width: 70px; height: 70px; font-size: 30px; cursor: pointer; display: flex; align-items: center; justify-content: center; transition: transform 0.2s;">
        ‚ù§Ô∏è
      </button>
      <span id="storyLikeCount" style="font-weight: bold; font-size: 1.2rem;">0</span>
    </div>
  </div>
</div>

<script type="module">
import { initializeApp } from "https://www.gstatic.com/firebasejs/10.7.1/firebase-app.js";
import { getAuth, createUserWithEmailAndPassword, signInWithEmailAndPassword, onAuthStateChanged, signOut } from "https://www.gstatic.com/firebasejs/10.7.1/firebase-auth.js";
import {
  getFirestore,
  collection,
  addDoc,
  serverTimestamp,
  query,
  orderBy,
  onSnapshot,
  doc,
  updateDoc,
  getDoc,
  arrayUnion,
  arrayRemove,
  where,
  getDocs,
  setDoc,
  deleteDoc
} from "https://www.gstatic.com/firebasejs/10.7.1/firebase-firestore.js";


const firebaseConfig = {
  apiKey: "AIzaSyAqXdF1640j6J1DXLlJiek3Z3vJxYOj9-w",
  authDomain: "mini-social-media-4743d.firebaseapp.com",
  projectId: "mini-social-media-4743d"
};

const app = initializeApp(firebaseConfig);
let currentStories = [];
let currentStoryIndex = 0;
let unsubscribeLikes = null;
const auth = getAuth(app);
const db = getFirestore(app);
/* DOM ELEMENTS */
const authDiv = document.getElementById("auth");
const appDiv = document.getElementById("app");
const navbar = document.getElementById("navbar");
const feed = document.getElementById("feed");
const userInfo = document.getElementById("userInfo");

const email = document.getElementById("email");
const password = document.getElementById("password");
const authMsg = document.getElementById("authMsg");

const loginBtn = document.getElementById("loginBtn");
const registerBtn = document.getElementById("registerBtn");
const logoutBtn = document.getElementById("logoutBtn");

const postModal = document.getElementById("postModal");
const openPostModal = document.getElementById("openPostModal");
const closePostModal = document.getElementById("closePostModal");

const postText = document.getElementById("postText");
const imageUrl = document.getElementById("mediaUrl");
const postBtn = document.getElementById("postBtn");

const addFriendModal = document.getElementById("addFriendModal");
const openAddFriendModal = document.getElementById("openAddFriendModal");
const closeAddFriendModal = document.getElementById("closeAddFriendModal");
const friendEmail = document.getElementById("friendEmail");
const addFriendBtn = document.getElementById("addFriendBtn");
const addFriendMsg = document.getElementById("addFriendMsg");

const friendsList = document.getElementById("friendsList");
const chatContainer = document.getElementById("chatContainer");
const noChatMessage = document.getElementById("noChatMessage");
const chatMessages = document.getElementById("chatMessages");
const chatHeader = document.getElementById("chatHeader");
const messageInput = document.getElementById("messageInput");
const sendMessageBtn = document.getElementById("sendMessageBtn");

const profileModal = document.getElementById("profileModal");
const openProfileModal = document.getElementById("openProfileModal");
const closeProfileModal = document.getElementById("closeProfileModal");
const profilePicDisplay = document.getElementById("profilePicDisplay");
const profilePicInput = document.getElementById("profilePicInput");
const uploadProfilePicBtn = document.getElementById("uploadProfilePicBtn");
const profileEmail = document.getElementById("profileEmail");
const profileFriendCount = document.getElementById("profileFriendCount");
const openChatsView = document.getElementById("openChatsView");

const feedBtn = document.getElementById("feedBtn");
const messagesBtn = document.getElementById("messagesBtn");
const notificationsBtn = document.getElementById("notificationsBtn");
const feedSection = document.getElementById("feedSection");
const chatSection = document.getElementById("chatSection");
const notificationsSection = document.getElementById("notificationsSection");
const notificationsList = document.getElementById("notificationsList");
const notificationBadge = document.getElementById("notificationBadge");
const navbarProfilePic = document.getElementById("navbarProfilePic");

let currentGroupId = null;
let currentChatFriend = null;
let currentCommentPostId = null;
let mediaRecorder = null;
let audioChunks = [];
let recordingStartTime = null;
let allUsersStoryBundles = [];


/* AUTH */
loginBtn.onclick = () => signInWithEmailAndPassword(auth, email.value, password.value)
  .catch(e => authMsg.innerText = e.message);

registerBtn.onclick = () => createUserWithEmailAndPassword(auth, email.value, password.value)
  .catch(e => authMsg.innerText = e.message);

logoutBtn.onclick = () => signOut(auth);

/* STATE */
onAuthStateChanged(auth, async user => {
  // Show the loader immediately when auth state starts checking
  const globalLoader = document.getElementById("globalLoader");
  if (globalLoader) globalLoader.style.display = "flex";

  if (user) {
    authDiv.style.display = "none";
    appDiv.style.display = "grid";
    navbar.style.display = "flex";
    userInfo.innerHTML = `üë§ ${user.email}`;
    
    // Initialize user in database
    const userRef = doc(db, "users", user.uid);
    const userSnap = await getDoc(userRef);
    
    if (!userSnap.exists()) {
      await setDoc(userRef, {
        email: user.email,
        friends: [],
        createdAt: serverTimestamp()
      });
    } else {
      const userData = userSnap.data();
      // Use 'pfp' or 'profilePic' - make sure this matches your upload logic!
      const userImg = userData.pfp || userData.profilePic;
      if (userImg) {
        navbarProfilePic.textContent = "";
        navbarProfilePic.style.backgroundImage = `url(${userImg})`;
        navbarProfilePic.style.backgroundSize = "cover";
        navbarProfilePic.style.backgroundPosition = "center";
      }
    }
    
    onSnapshot(userRef, (snap) => {
      const data = snap.data();
      const userImg = data?.pfp || data?.profilePic;
      if (snap.exists() && userImg) {
        navbarProfilePic.textContent = "";
        navbarProfilePic.style.backgroundImage = `url(${userImg})`;
      }
    });

    // üî• WAITING FOR DATA
    // We wrap your load functions in Promise.all so the loader hides 
    // ONLY after everything is fetched from Firebase.
    try {
      await Promise.all([
        loadFeed(),
        loadFriends(),
        loadNotifications(),
        loadStories(),
        loadGroups()
      ]);
    } catch (err) {
      console.error("Loading error:", err);
    }

    // ‚úÖ Everything is ready! Hide the loader.
    if (globalLoader) {
      setTimeout(() => {
        globalLoader.style.opacity = "0"; // Smooth fade out
        setTimeout(() => globalLoader.style.display = "none", 500);
      }, 500);
    }

  } else {
    authDiv.style.display = "block";
    appDiv.style.display = "none";
    navbar.style.display = "none";
    if (globalLoader) globalLoader.style.display = "none";
  }
});


/* MODAL */
openPostModal.onclick = () => postModal.style.display = "flex";
closePostModal.onclick = () => postModal.style.display = "none";

openAddFriendModal.onclick = () => {
  addFriendModal.style.display = "flex";
  friendEmail.value = "";
  addFriendMsg.innerText = "";
};
closeAddFriendModal.onclick = () => addFriendModal.style.display = "none";

/* ADD FRIEND */
addFriendBtn.onclick = async () => {
  const email = friendEmail.value.trim();
  if (!email) return;
  
  try {
    addFriendMsg.innerText = "Searching...";
    
    // Check if user exists
    const usersRef = collection(db, "users");
    const q = query(usersRef, where("email", "==", email));
    const snap = await getDocs(q);
    
    if (snap.empty) {
      addFriendMsg.innerText = "‚ùå User not found";
      return;
    }
    
    const friendData = snap.docs[0];
    const friendId = friendData.id;
    
    if (friendId === auth.currentUser.uid) {
      addFriendMsg.innerText = "‚ùå Can't add yourself";
      return;
    }
    
    // Check if already friends
    const userRef = doc(db, "users", auth.currentUser.uid);
    const userSnap = await getDoc(userRef);
    const userFriends = userSnap.data().friends || [];
    
    if (userFriends.includes(friendId)) {
      addFriendMsg.innerText = "‚ùå Already friends";
      return;
    }
    
    // Send friend request
    await addDoc(collection(db, "friendRequests"), {
      from: auth.currentUser.uid,
      fromEmail: auth.currentUser.email,
      to: friendId,
      status: "pending", // MUST ADD THIS to match rules
      createdAt: serverTimestamp()
    });
    
    addFriendMsg.innerText = "‚úÖ Request sent!";
    setTimeout(() => {
      addFriendModal.style.display = "none";
    }, 1000);
  } catch (e) {
    console.error(e);
    addFriendMsg.innerText = "‚úÖ Request sent!";
    setTimeout(() => {
      addFriendModal.style.display = "none";
    }, 1000);
  }
};

/* SEND MESSAGE */
sendMessageBtn.onclick = async () => {
  const text = messageInput.value.trim();
  
  // 1. Validation: Ensure there's text AND a target (either a group or a friend)
  if (!text || (!currentChatFriend && !currentGroupId)) return;

  try {
    if (currentGroupId) {
      // --- ROUTE TO GROUP CHAT ---
      await addDoc(collection(db, "groups", currentGroupId, "messages"), {
        text: text,
        sender: auth.currentUser.uid,
        senderEmail: auth.currentUser.email.split("@")[0], // Simplified name
        createdAt: serverTimestamp()
      });
    } else if (currentChatFriend) {
      // --- ROUTE TO PRIVATE CHAT ---
      const conversationId = [auth.currentUser.uid, currentChatFriend].sort().join("_");
      await addDoc(collection(db, "conversations", conversationId, "messages"), {
        text: text,
        sender: auth.currentUser.uid,
        senderEmail: auth.currentUser.email,
        createdAt: serverTimestamp()
      });
    }

    // Clear input after successful send
    messageInput.value = "";
    
  } catch (e) {
    console.error("Error sending message: ", e);
    alert("Could not send message. Check console for details.");
  }
};

messageInput.onkeypress = (e) => {
  if (e.key === "Enter") sendMessageBtn.click();
};

/* VOICE CHAT */
const recordVoiceChatBtn = document.getElementById("recordVoiceChatBtn");
const stopVoiceChatBtn = document.getElementById("stopVoiceChatBtn");
const sendVoiceChatBtn = document.getElementById("sendVoiceChatBtn");
const voiceChatRecordingUI = document.getElementById("voiceChatRecordingUI");
const chatRecordingTime = document.getElementById("chatRecordingTime");
let chatMediaRecorder = null;
let chatAudioChunks = [];
let chatRecordingStartTime = null;

let chatRecordingInterval = null;

recordVoiceChatBtn.onclick = async () => {
  try {
    const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
    chatMediaRecorder = new MediaRecorder(stream);
    chatAudioChunks = [];
    chatRecordingStartTime = Date.now();
    
    chatMediaRecorder.ondataavailable = (event) => {
      console.log("ondataavailable fired, chunk size:", event.data.size);
      if (event.data.size > 0) {
        chatAudioChunks.push(event.data);
      }
    };
    
    // Start with timeslice to ensure ondataavailable fires periodically
    chatMediaRecorder.start(100);
    console.log("MediaRecorder started");
    
    recordVoiceChatBtn.style.display = "none";
    voiceChatRecordingUI.style.display = "block";
    messageInput.style.display = "none";
    sendMessageBtn.style.display = "none";
    
    // Update recording time
    chatRecordingInterval = setInterval(() => {
      const elapsed = Math.floor((Date.now() - chatRecordingStartTime) / 1000);
      const mins = Math.floor(elapsed / 60);
      const secs = elapsed % 60;
      chatRecordingTime.innerText = `${mins.toString().padStart(2, "0")}:${secs.toString().padStart(2, "0")}`;
    }, 100);
    
    stopVoiceChatBtn.onclick = () => {
      clearInterval(chatRecordingInterval);
      if (chatMediaRecorder && chatMediaRecorder.state !== "inactive") {
        // Request any remaining data before stopping
        chatMediaRecorder.requestData();
        chatMediaRecorder.stop();
        // Stop all tracks
        stream.getTracks().forEach(track => track.stop());
        console.log("MediaRecorder stopped");
      }
    };
  } catch (e) {
    console.error("Microphone access denied:", e);
    alert("Please allow microphone access to record voice messages");
  }
};

sendVoiceChatBtn.onclick = async () => {
  // Auto-stop recording when sending
  if (chatMediaRecorder && chatMediaRecorder.state !== "inactive") {
    clearInterval(chatRecordingInterval);
    chatMediaRecorder.requestData();
    chatMediaRecorder.stop();
  }
  
  console.log("Send clicked, chunks:", chatAudioChunks.length, "Friend:", currentChatFriend);
  
  if (!currentChatFriend) {
    alert("Please select a friend to chat with");
    return;
  }
  
  if (chatAudioChunks.length === 0) {
    alert("No audio recorded. Please record a message first.");
    return;
  }
  
  const conversationId = [auth.currentUser.uid, currentChatFriend].sort().join("_");
  const audioBlob = new Blob(chatAudioChunks, { type: "audio/webm" });
  const reader = new FileReader();
  
  reader.onload = async (event) => {
    const audioBase64 = event.target.result;
    
    try {
      await addDoc(collection(db, "conversations", conversationId, "messages"), {
        audio: audioBase64,
        isVoice: true,
        sender: auth.currentUser.uid,
        senderEmail: auth.currentUser.email,
        createdAt: serverTimestamp()
      });
      
      chatAudioChunks = [];
      voiceChatRecordingUI.style.display = "none";
      recordVoiceChatBtn.style.display = "block";
      messageInput.style.display = "block";
      sendMessageBtn.style.display = "block";
    } catch (e) {
      console.error("Error sending voice message:", e);
      alert("Error sending voice message. Try again.");
    }
  };
  
  reader.readAsDataURL(audioBlob);
};

/* PROFILE */
// 1. Updated Open Modal Function
openProfileModal.onclick = () => {
  profileModal.style.display = "flex";
  profileEmail.innerText = auth.currentUser.email;
  
  const userRef = doc(db, "users", auth.currentUser.uid);
  getDoc(userRef).then(snap => {
    if (snap.exists()) {
      const data = snap.data();
      
      // Load Profile Pic (Existing Logic)
      profileFriendCount.innerText = data.friends?.length || 0;
      if (data.profilePic) {
        profilePicDisplay.textContent = "";
        profilePicDisplay.style.backgroundImage = `url(${data.profilePic})`;
        profilePicDisplay.style.backgroundSize = "cover";
        profilePicDisplay.style.backgroundPosition = "center";
      }

      // Load Bio (New Logic)
      document.getElementById("profileBioInput").value = data.bio || "";
    }
  });
};

// 2. New Save Bio Function
document.getElementById("saveBioBtn").onclick = async () => {
  const bioValue = document.getElementById("profileBioInput").value;
  const userRef = doc(db, "users", auth.currentUser.uid);
  
  try {
    await updateDoc(userRef, { bio: bioValue });
    alert("Bio saved!");
  } catch (error) {
    console.error("Error saving bio:", error);
    alert("Error saving bio.");
  }
};
closeProfileModal.onclick = () => profileModal.style.display = "none";

uploadProfilePicBtn.onclick = () => profilePicInput.click();

profilePicInput.onchange = async (e) => {
  const file = e.target.files[0];
  if (!file) return;
  
  const reader = new FileReader();
  reader.onload = async (event) => {
    const base64 = event.target.result;
    const userRef = doc(db, "users", auth.currentUser.uid);
    
    // üî• CHANGE: Use 'pfp' instead of 'profilePic'
    await updateDoc(userRef, {
      pfp: base64 
    });
    
    // Update UI elements
    [profilePicDisplay, navbarProfilePic].forEach(el => {
      el.textContent = "";
      el.style.backgroundImage = `url(${base64})`;
      el.style.backgroundSize = "cover";
      el.style.backgroundPosition = "center";
    });
  };
  reader.readAsDataURL(file);
};
/* USER PROFILE VIEWING */
window.closeUserProfile = () => {
  document.getElementById("userProfileModal").style.display = "none";
};/* NAVBAR BUTTONS */
feedBtn.onclick = () => {
  feedSection.style.display = "block";
  chatSection.style.display = "none";
  notificationsSection.style.display = "none";
  feedBtn.style.opacity = "1";
  messagesBtn.style.opacity = "0.6";
  notificationsBtn.style.opacity = "0.6";
};

messagesBtn.onclick = () => {
  feedSection.style.display = "none";
  chatSection.style.display = "block";
  notificationsSection.style.display = "none";
  feedBtn.style.opacity = "0.6";
  messagesBtn.style.opacity = "1";
  notificationsBtn.style.opacity = "0.6";
};

notificationsBtn.onclick = () => {
  feedSection.style.display = "none";
  chatSection.style.display = "none";
  notificationsSection.style.display = "block";
  feedBtn.style.opacity = "0.6";
  messagesBtn.style.opacity = "0.6";
  notificationsBtn.style.opacity = "1";
};

/* POST */
postBtn.onclick = async () => {
  if (!postText.value.trim()) return;
  await addDoc(collection(db, "posts"), {
  text: postText.value,
  image: imageUrl.value,
  user: auth.currentUser.email.split("@")[0],
  userId: auth.currentUser.uid,
  uid: auth.currentUser.uid,
  likedBy: [],
  reactions: {},
  createdAt: serverTimestamp()
});

  postText.value = "";
  imageUrl.value = "";
  postModal.style.display = "none";
};

/* FEED */
function loadFeed() {
  const q = query(collection(db, "posts"), orderBy("createdAt", "desc"));
  onSnapshot(q, snap => {
  feed.innerHTML = "";
  snap.forEach(d => {
    const p = d.data();
    const uid = auth.currentUser.uid;
    const reactions = p.reactions || {};
    const reactionEmojis = ['üëç', '‚ù§Ô∏è', 'üòÇ', 'üòÆ', 'üò¢'];
    const userReaction = Object.entries(reactions).find(([, users]) => users?.includes(uid))?.[0];
    const reactCounts = Object.entries(reactions).map(([emoji, users]) => `${emoji} ${users?.length || 0}`).join(' ');
    const isOwner = p.userId === uid;

  feed.innerHTML += `
    <div class="post">
      <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;">
       <b onclick="viewPublicProfile('${p.userId}')" style="cursor: pointer; color: #667eea; text-decoration: underline;">${p.user}</b>
          ${isOwner ? `<div style="display: flex; gap: 5px;">
            <button onclick="editPost('${d.id}')" style="padding: 4px 8px; font-size: 12px; background: rgba(102,126,234,0.3); border: none; border-radius: 4px; color: white; cursor: pointer;">‚úèÔ∏è</button>
            <button onclick="deletePost('${d.id}')" style="padding: 4px 8px; font-size: 12px; background: rgba(255,71,87,0.3); border: none; border-radius: 4px; color: white; cursor: pointer;">üóëÔ∏è</button>
          </div>` : ''}
        </div>
        <p>${p.text}</p>
        ${p.image ? `<img src="${p.image}">` : ""}
        <div class="actions" style="display: flex; gap: 15px; margin: 10px 0;">
          <div style="display: flex; gap: 5px; flex-wrap: wrap;">
            ${reactionEmojis.map(emoji => `
              <button onclick="toggleReaction('${d.id}', '${emoji}')" style="padding: 4px 8px; background: ${userReaction === emoji ? 'rgba(102,126,234,0.4)' : 'rgba(255,255,255,0.1)'}; border: 1px solid rgba(102,126,234,${userReaction === emoji ? '0.6' : '0.2'}); border-radius: 6px; color: white; cursor: pointer; font-size: 14px;">${emoji}</button>
            `).join('')}
          </div>
          ${reactCounts ? `<span style="font-size: 12px; opacity: 0.7;">${reactCounts}</span>` : ''}
        </div>
        <span onclick="toggleCommentsSection('${d.id}')" style="cursor: pointer; color: #667eea; text-decoration: underline;">üí¨ ${d.data().commentCount || 0} Comments</span>
        <div class="comments-section" id="comments-${d.id}" style="display: none; margin-top: 15px; padding-top: 15px; border-top: 1px solid rgba(255, 255, 255, 0.2);">
          <div id="commentsList-${d.id}" style="margin-bottom: 10px;"></div>
          <div style="display: flex; gap: 8px;">
            <input id="commentInput-${d.id}" placeholder="Add a comment..." style="flex: 1; padding: 8px 12px !important; margin: 0 !important; font-size: 13px;">
            <button onclick="addCommentToPost('${d.id}')" style="padding: 8px 12px !important; margin: 0 !important; width: auto; font-size: 13px; background: linear-gradient(135deg, #667eea, #764ba2);">‚ûï</button>
            <button onclick="recordVoiceComment('${d.id}')" style="padding: 8px 12px !important; margin: 0 !important; width: auto; font-size: 13px; background: linear-gradient(135deg, #f093fb, #f5576c);">üé§</button>
          </div>
          <div id="voiceCommentUI-${d.id}" style="display: none; margin-top: 10px; padding: 10px; background: rgba(255,255,255,0.1); border-radius: 8px; text-align: center;">
            <p style="margin: 0 0 8px 0; font-weight: 600; font-size: 12px;" id="voiceCommentTime-${d.id}">00:00</p>
            <div style="display: flex; gap: 8px;">
              <button onclick="stopVoiceComment('${d.id}')" style="flex: 1; padding: 6px; background: #ff4757; border: none; border-radius: 6px; color: white; cursor: pointer; font-weight: 600; font-size: 12px;">‚èπ Stop</button>
              <button onclick="sendVoiceComment('${d.id}')" style="flex: 1; padding: 6px; background: linear-gradient(135deg, #f093fb, #f5576c); border: none; border-radius: 6px; color: white; cursor: pointer; font-weight: 600; font-size: 12px;">üì§ Send</button>
            </div>
          </div>
        </div>
      </div>
    `;
  });
});

}

window.toggleLike = async (postId) => {
  const postRef = doc(db, "posts", postId);
  const uid = auth.currentUser.uid;

  const snap = await getDoc(postRef);
  const likedBy = snap.data().likedBy || [];

  if (likedBy.includes(uid)) {
    // UNLIKE
    await updateDoc(postRef, {
      likedBy: arrayRemove(uid)
    });
  } else {
    // LIKE
    await updateDoc(postRef, {
      likedBy: arrayUnion(uid)
    });
  }
};

/* REACTIONS */
window.toggleReaction = async (postId, emoji) => {
  const postRef = doc(db, "posts", postId);
  const uid = auth.currentUser.uid;
  
  const snap = await getDoc(postRef);
  const reactions = snap.data().reactions || {};
  
  // Remove user from all reactions first
  Object.keys(reactions).forEach(e => {
    if (reactions[e]?.includes(uid)) {
      reactions[e] = reactions[e].filter(id => id !== uid);
      if (reactions[e].length === 0) delete reactions[e];
    }
  });
  
  // Add to new reaction
  if (!reactions[emoji]) reactions[emoji] = [];
  reactions[emoji].push(uid);
  
  await updateDoc(postRef, { reactions });
};

/* EDIT POST */
window.editPost = async (postId) => {
  const text = prompt("Edit your post:");
  if (!text) return;
  
  try {
    await updateDoc(doc(db, "posts", postId), { text });
  } catch (e) {
    alert("Error editing post");
  }
};

/* DELETE POST */
window.deletePost = async (postId) => {
  if (!confirm("Delete this post?")) return;
  
  try {
    await deleteDoc(doc(db, "posts", postId));
  } catch (e) {
    alert("Error deleting post");
  }
};

/* DELETE COMMENT */
window.deleteComment = async (postId, commentId) => {
  if (!confirm("Delete this comment?")) return;
  
  try {
    await deleteDoc(doc(db, "posts", postId, "comments", commentId));
    const postRef = doc(db, "posts", postId);
    const snap = await getDoc(postRef);
    const count = (snap.data().commentCount || 1) - 1;
    await updateDoc(postRef, { commentCount: Math.max(0, count) });
  } catch (e) {
    alert("Error deleting comment");
  }
};

/* EDIT COMMENT */
window.editComment = async (postId, commentId) => {
  const text = prompt("Edit your comment:");
  if (!text) return;
  
  try {
    await updateDoc(doc(db, "posts", postId, "comments", commentId), { text });
  } catch (e) {
    alert("Error editing comment");
  }
};
window.nextStory = () => {
  // Check if there is another story in the array
  if (currentStoryIndex < currentStories.length - 1) {
    currentStoryIndex++;
    // This updates the viewer with the next story's data
    displayStory(currentStories[currentStoryIndex]); 
  } else {
    // If it's the last one, close the viewer
    document.getElementById("storyViewer").style.display = "none";
  }
};

window.prevStory = () => {
  // Check if we aren't at the first story
  if (currentStoryIndex > 0) {
    currentStoryIndex--;
    displayStory(currentStories[currentStoryIndex]);
  }
};

/* LOAD FRIENDS */
function loadFriends() {
  const userRef = doc(db, "users", auth.currentUser.uid);
  onSnapshot(userRef, async (snap) => {
    if (!snap.exists()) return;
    
    const userData = snap.data();
    const friendIds = userData.friends || [];
    
    friendsList.innerHTML = "";
    
    if (friendIds.length === 0) {
      friendsList.innerHTML = "<p style='text-align: center; opacity: 0.6; margin-top: 20px;'>No friends yet</p>";
      return;
    }
    
    for (const friendId of friendIds) {
      const friendSnap = await getDoc(doc(db, "users", friendId));
      if (friendSnap.exists()) {
        const friendData = friendSnap.data();
        const friendDiv = document.createElement("div");
        friendDiv.className = "friend-item";
        
        const pic = friendData.profilePic ? `<img src="${friendData.profilePic}" style="width: 35px; height: 35px; border-radius: 50%; object-fit: cover; margin-right: 10px;">` : `<span style="font-size: 20px; margin-right: 10px;">üë§</span>`;
        
        friendDiv.innerHTML = `<div style="display: flex; align-items: center; justify-content: space-between; width: 100%;">
          <div style="display: flex; align-items: center; cursor: pointer; flex: 1;" onclick="openChat('${friendId}', '${friendData.email}'); event.stopPropagation();">
            ${pic}
            <span>${friendData.email.split("@")[0]}</span>
          </div>
          <button onclick="deleteFriend('${friendId}'); event.stopPropagation();" style="padding: 4px 8px; font-size: 12px; background: rgba(255,71,87,0.3); border: none; border-radius: 4px; color: white; cursor: pointer;">‚úï</button>
        </div>`;
        friendsList.appendChild(friendDiv);
      }
    }
  });
}

/* DELETE FRIEND */
window.deleteFriend = async (friendId) => {
  if (!confirm("Remove this friend?")) return;
  
  try {
    const uid = auth.currentUser.uid;
    const userRef = doc(db, "users", uid);
    const friendRef = doc(db, "users", friendId);
    
    await updateDoc(userRef, { friends: arrayRemove(friendId) });
    await updateDoc(friendRef, { friends: arrayRemove(uid) });
    
    alert("Friend removed successfully");
  } catch (e) {
    console.error("Error removing friend:", e);
    alert("Error removing friend: " + e.message);
  }
};

/* OPEN CHAT */
window.openChat = function(friendId, friendEmail) {
  currentChatFriend = friendId;
  
  // Update UI - highlight the active friend in the sidebar
  document.querySelectorAll(".friend-item").forEach(el => el.classList.remove("active"));
  if (window.event && window.event.currentTarget) {
    window.event.currentTarget.classList.add("active");
  }
  
  noChatMessage.style.display = "none";
  chatContainer.style.display = "flex";

  // 1Ô∏è‚É£ UPDATE HEADER: Make the name clickable to open profile
  const displayName = friendEmail.split("@")[0];
  chatHeader.innerHTML = `
    üí¨ <span style="cursor: pointer; text-decoration: underline; color: #ffb400;" 
             onclick="viewPublicProfile('${friendId}')">
      ${displayName}
    </span>
  `;

  chatMessages.innerHTML = "";
  
  // Load messages from Firestore
  const conversationId = [auth.currentUser.uid, friendId].sort().join("_");
  const q = query(
    collection(db, "conversations", conversationId, "messages"),
    orderBy("createdAt", "asc")
  );
  
  onSnapshot(q, (snap) => {
    chatMessages.innerHTML = "";
    snap.forEach((doc) => {
      const msg = doc.data();
      const isOwn = msg.sender === auth.currentUser.uid;
      const msgEl = document.createElement("div");
      msgEl.className = `message ${isOwn ? "own" : "other"}`;
      
      // 2Ô∏è‚É£ UPDATE MESSAGES: Add a clickable name above the text bubble
      const nameInChat = msg.senderEmail ? msg.senderEmail.split('@')[0] : 'User';
      const senderLabel = `
        <div style="font-size: 10px; opacity: 0.7; margin-bottom: 3px; cursor: pointer; text-decoration: underline;" 
             onclick="viewPublicProfile('${msg.sender}')">
          ${nameInChat}
        </div>`;

      if (msg.isVoice) {
        msgEl.innerHTML = `
          ${senderLabel}
          <audio controls class="voice-message-player">
            <source src="${msg.audio}" type="audio/webm">
          </audio>`;
      } else {
        msgEl.innerHTML = `
          ${senderLabel}
          <div>${msg.text}</div>`;
      }
      
      chatMessages.appendChild(msgEl);
    });
    chatMessages.scrollTop = chatMessages.scrollHeight;
  });
}

/* SEND FRIEND REQUEST */
window.sendFriendRequest = async (friendId, friendEmail) => {
  try {
    // Validate inputs
    if (!friendId || friendId === auth.currentUser.uid) {
      alert("Invalid friend selection");
      return;
    }
    
    // Check if already friends
    const userSnap = await getDoc(doc(db, "users", auth.currentUser.uid));
    if (userSnap.exists()) {
      const friends = userSnap.data().friends || [];
      if (friends.includes(friendId)) {
        alert("You are already friends! üë•");
        return;
      }
    }
    
    // Check if request already exists (both directions)
    const sentQ = query(
      collection(db, "friendRequests"), 
      where("from", "==", auth.currentUser.uid),
      where("to", "==", friendId)
    );
    const receivedQ = query(
      collection(db, "friendRequests"), 
      where("from", "==", friendId),
      where("to", "==", auth.currentUser.uid)
    );
    
    const [sentSnap, receivedSnap] = await Promise.all([
      getDocs(sentQ),
      getDocs(receivedQ)
    ]);
    
    if (!sentSnap.empty) {
      alert("Friend request already sent! ‚è≥");
      return;
    }
    
    if (!receivedSnap.empty) {
      alert("This user already sent you a friend request! Check your notifications üîî");
      return;
    }
    
    // Create the friend request with ALL required fields
    // Replace your addDoc section with this:
await addDoc(collection(db, "friendRequests"), {
  from: auth.currentUser.uid,
  fromEmail: auth.currentUser.email,
  to: friendId,
  status: "pending", // MUST ADD THIS to match rules
  createdAt: serverTimestamp()
});
    
    console.log("Friend request sent successfully");
    alert("Friend request sent! ‚úÖ");
  } catch (e) {
    console.error("Error sending friend request:", e);
    alert("Error sending friend request: " + e.message);
  }
};

/* LOAD NOTIFICATIONS */
function loadNotifications() {
  const q = query(
    collection(db, "friendRequests"), 
    where("to", "==", auth.currentUser.uid),
    where("status", "==", "pending")  // Only show pending requests
  );
  
  onSnapshot(q, (snap) => {
    const requests = [];
    snap.forEach(doc => {
      requests.push({ id: doc.id, ...doc.data() });
    });
    
    console.log("Loaded notifications:", requests.length);
    
    notificationBadge.innerText = requests.length;
    notificationBadge.style.display = requests.length > 0 ? "flex" : "none";
    
    notificationsList.innerHTML = "";
    
    if (requests.length === 0) {
      notificationsList.innerHTML = "<p style='text-align: center; opacity: 0.6; padding: 20px;'>No notifications</p>";
      return;
    }
    
    requests.forEach(req => {
      const notifDiv = document.createElement("div");
      notifDiv.style.cssText = "background: rgba(255,255,255,0.1); padding: 15px; border-radius: 10px; margin-bottom: 10px; border: 1px solid rgba(255,255,255,0.2);";
      notifDiv.innerHTML = `
        <div style="font-weight: 600; margin-bottom: 10px;">
          ${req.fromEmail ? req.fromEmail.split("@")[0] : 'Someone'} wants to be your friend
        </div>
        <div style="display: flex; gap: 10px;">
          <button style="flex: 1; padding: 8px 12px; background: linear-gradient(135deg, #667eea, #764ba2); border: none; border-radius: 8px; color: white; cursor: pointer; font-weight: 600;" onclick="acceptFriendRequest('${req.id}', '${req.from}')">‚úÖ Accept</button>
          <button style="flex: 1; padding: 8px 12px; background: rgba(255,255,255,0.1); border: 1px solid rgba(255,255,255,0.2); border-radius: 8px; color: white; cursor: pointer; font-weight: 600;" onclick="declineFriendRequest('${req.id}')">‚ùå Decline</button>
        </div>
      `;
      notificationsList.appendChild(notifDiv);
    });
  }, (error) => {
    console.error("Error loading notifications:", error);
  });
}

/* ACCEPT FRIEND REQUEST */
window.acceptFriendRequest = async (requestId, friendId) => {
  console.log("Accepting friend request:", requestId, friendId);
  
  try {
    // Get the request first to verify it exists
    const requestRef = doc(db, "friendRequests", requestId);
    const requestSnap = await getDoc(requestRef);
    
    if (!requestSnap.exists()) {
      alert("Friend request not found");
      return;
    }
    
    // 1. Update the request status to "accepted" FIRST
    await updateDoc(requestRef, {
      status: "accepted",
      acceptedAt: serverTimestamp()
    });
    
    console.log("Request status updated to accepted");
    
    // 2. Add to both users' friends arrays
    const userRef = doc(db, "users", auth.currentUser.uid);
    const friendRef = doc(db, "users", friendId);
    
    // Update current user's friends list
    await updateDoc(userRef, {
      friends: arrayUnion(friendId)
    });
    
    console.log("Added friend to current user");
    
    // Update friend's friends list
    await updateDoc(friendRef, {
      friends: arrayUnion(auth.currentUser.uid)
    });
    
    console.log("Added current user to friend's list");
    
    // 3. Delete the request after successful acceptance
    await deleteDoc(requestRef);
    
    console.log("Friend request deleted");
    
    alert("Friend request accepted! üéâ");
    
    // Reload friends list to show new friend
    loadFriends();
  } catch (e) {
    console.error("Error accepting friend request:", e);
    alert("Error accepting friend request: " + e.message);
  }
};

/* DECLINE FRIEND REQUEST */
window.declineFriendRequest = async (requestId) => {
  try {
    await deleteDoc(doc(db, "friendRequests", requestId));
    console.log("Friend request declined");
  } catch (e) {
    console.error("Error declining friend request:", e);
    alert("Error declining request: " + e.message);
  }
};

/* COMMENTS */
const commentsModal = document.getElementById("commentsModal");
const commentsList = document.getElementById("commentsList");
const commentInput = document.getElementById("commentInput");
const postCommentBtn = document.getElementById("postCommentBtn");
const closeCommentsModal = document.getElementById("closeCommentsModal");
const startVoiceBtn = document.getElementById("startVoiceBtn");
const stopVoiceBtn = document.getElementById("stopVoiceBtn");
const sendVoiceBtn = document.getElementById("sendVoiceBtn");
const voiceRecordingUI = document.getElementById("voiceRecordingUI");
const recordingTime = document.getElementById("recordingTime");

if (closeCommentsModal) {
  closeCommentsModal.onclick = () => commentsModal.style.display = "none";
}

window.toggleCommentsSection = (postId) => {
  const section = document.getElementById(`comments-${postId}`);
  section.style.display = section.style.display === "none" ? "block" : "none";
  
  if (section.style.display === "block") {
    loadCommentsForPost(postId);
  }
};

function loadCommentsForPost(postId) {
  const q = query(collection(db, "posts", postId, "comments"), orderBy("createdAt", "asc"));
  const commentsList = document.getElementById(`commentsList-${postId}`);
  
  onSnapshot(q, async (snap) => {
    commentsList.innerHTML = "";
    let commentCount = 0;
    snap.forEach((commentDoc) => {
      const comment = commentDoc.data();
      const uid = auth.currentUser.uid;
      const isOwner = comment.userId === uid;
      const commentDiv = document.createElement("div");
      commentCount++;
      
      if (comment.isVoice) {
        commentDiv.style.cssText = "background: rgba(255,255,255,0.1); padding: 8px; border-radius: 8px; margin-bottom: 8px;";
        commentDiv.innerHTML = `
          <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 6px;">
            <div style="font-weight: 600; font-size: 12px;">${comment.user}</div>
            ${isOwner ? `<div style="display: flex; gap: 5px;">
              <button onclick="deleteComment('${postId}', '${commentDoc.id}')" style="padding: 2px 6px; font-size: 11px; background: rgba(255,71,87,0.3); border: none; border-radius: 3px; color: white; cursor: pointer;">üóëÔ∏è</button>
            </div>` : ''}
          </div>
          <audio controls class="voice-message-player"><source src="${comment.audio}" type="audio/webm"></audio>
        `;
      } else {
        commentDiv.style.cssText = "background: rgba(255,255,255,0.1); padding: 8px; border-radius: 8px; margin-bottom: 8px;";
        commentDiv.innerHTML = `
          <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 4px;">

<div style="font-weight: 600; font-size: 12px; cursor: pointer; color: #667eea;" onclick="viewPublicProfile('${comment.userId}')">${comment.user}</div>
            ${isOwner ? `<div style="display: flex; gap: 5px;">
              <button onclick="editComment('${postId}', '${commentDoc.id}')" style="padding: 2px 6px; font-size: 11px; background: rgba(102,126,234,0.3); border: none; border-radius: 3px; color: white; cursor: pointer;">‚úèÔ∏è</button>
              <button onclick="deleteComment('${postId}', '${commentDoc.id}')" style="padding: 2px 6px; font-size: 11px; background: rgba(255,71,87,0.3); border: none; border-radius: 3px; color: white; cursor: pointer;">üóëÔ∏è</button>
            </div>` : ''}
          </div>
          <div style="font-size: 13px; color: rgba(255,255,255,0.9);">${comment.text}</div>
        `;
      }
      commentsList.appendChild(commentDiv);
    });
    
    // Update the comment count in the post
    const postRef = doc(db, "posts", postId);
    await updateDoc(postRef, { commentCount });
  });
}

/* ADD COMMENT TO POST */
window.addCommentToPost = async (postId) => {
  const input = document.getElementById(`commentInput-${postId}`);
  const text = input.value.trim();
  if (!text) return;
  
  try {
    await addDoc(collection(db, "posts", postId, "comments"), {
      text: text,
      user: auth.currentUser.email.split("@")[0],
      userId: auth.currentUser.uid,
      createdAt: serverTimestamp(),
      isVoice: false
    });
    
    input.value = "";
    loadCommentsForPost(postId);
  } catch (e) {
    console.error("Error adding comment:", e);
    alert("Error posting comment: " + e.message);
  }
};

/* VOICE COMMENTS */
let currentVoiceCommentPostId = null;
let currentVoiceCommentRecorder = null;
let currentVoiceCommentChunks = [];
let voiceCommentStartTime = null;

window.recordVoiceComment = async (postId) => {
  try {
    const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
    currentVoiceCommentPostId = postId;
    currentVoiceCommentRecorder = new MediaRecorder(stream);
    currentVoiceCommentChunks = [];
    voiceCommentStartTime = Date.now();
    
    currentVoiceCommentRecorder.ondataavailable = (event) => {
      currentVoiceCommentChunks.push(event.data);
    };
    
    currentVoiceCommentRecorder.start();
    document.getElementById(`voiceCommentUI-${postId}`).style.display = "block";
    
    const interval = setInterval(() => {
      const elapsed = Math.floor((Date.now() - voiceCommentStartTime) / 1000);
      const mins = Math.floor(elapsed / 60);
      const secs = elapsed % 60;
      document.getElementById(`voiceCommentTime-${postId}`).innerText = `${mins.toString().padStart(2, "0")}:${secs.toString().padStart(2, "0")}`;
    }, 100);
    
    window[`stopVoiceComment_${postId}_interval`] = interval;
  } catch (e) {
    console.error("Microphone access denied:", e);
    alert("Please allow microphone access");
  }
};

window.stopVoiceComment = (postId) => {
  clearInterval(window[`stopVoiceComment_${postId}_interval`]);
  if (currentVoiceCommentRecorder && currentVoiceCommentRecorder.state !== "inactive") {
    currentVoiceCommentRecorder.stop();
  }
};

window.sendVoiceComment = (postId) => {
  if (currentVoiceCommentChunks.length === 0) return;
  
  const audioBlob = new Blob(currentVoiceCommentChunks, { type: "audio/webm" });
  const reader = new FileReader();
  
  reader.onload = async (event) => {
    const audioBase64 = event.target.result;
    
    try {
      await addDoc(collection(db, "posts", postId, "comments"), {
        audio: audioBase64,
        isVoice: true,
        user: auth.currentUser.email.split("@")[0],
        userId: auth.currentUser.uid,
        createdAt: serverTimestamp()
      });
      
      document.getElementById(`voiceCommentUI-${postId}`).style.display = "none";
      currentVoiceCommentChunks = [];
      loadCommentsForPost(postId);
    } catch (e) {
      console.error("Error sending voice comment:", e);
      alert("Error sending voice comment: " + e.message);
    }
  };
  
  reader.readAsDataURL(audioBlob);
};

/* STORIES */
document.addEventListener("DOMContentLoaded", () => {

  const addStoryBtn = document.getElementById("addStoryBtn");
  const storyModal = document.getElementById("storyModal");
  const storyImageUrl = document.getElementById("storyImageUrl");
  const storyPreview = document.getElementById("storyPreview");
  const storyPreviewText = document.getElementById("storyPreviewText");
  const storyPostBtn = document.getElementById("storyPostBtn");
  const closeStoryModal = document.getElementById("closeStoryModal");

  if (addStoryBtn && storyModal && storyImageUrl && storyPreview && storyPreviewText) {
    addStoryBtn.onclick = () => {
      storyModal.style.display = "flex";
      storyImageUrl.value = "";
      storyPreview.style.display = "none";
      storyPreviewText.style.display = "block";
    };
  }

  if (storyImageUrl && storyPreview && storyPreviewText) {
    storyImageUrl.addEventListener("input", () => {
      const url = storyImageUrl.value.trim();
      if (url) {
        storyPreview.src = url;
        storyPreview.style.display = "block";
        storyPreviewText.style.display = "none";
      } else {
        storyPreview.style.display = "none";
        storyPreviewText.style.display = "block";
      }
    });
  }

  if (storyPostBtn && storyModal && storyImageUrl) {
    storyPostBtn.onclick = async () => {
  const user = auth.currentUser;
  if (!user || !storyImageUrl.value) return;

  try {
    // 1. Get your PFP from your user profile first
    const userDoc = await getDoc(doc(db, "users", user.uid));
    const userData = userDoc.data();
    
    // We use the 'pfp' field we just updated above
    const myCurrentPfp = userData && userData.pfp ? userData.pfp : "";

    // 2. Add the story with BOTH the story image and the PFP
    await addDoc(collection(db, "stories"), {
      userId: user.uid,
      user: user.email,
      profilePic: myCurrentPfp,  // <--- The circle uses this
      image: storyImageUrl.value, // <--- The story viewer uses this
      createdAt: Date.now(),
      expiresAt: Date.now() + 24 * 60 * 60 * 1000,
      likes: []
    });

    storyModal.style.display = "none";
    storyImageUrl.value = "";
  } catch (e) {
    console.error("Error posting story:", e);
  }
};
  }

  if (closeStoryModal && storyModal) {
    closeStoryModal.onclick = () => {
      storyModal.style.display = "none";
    };
  }

});





const storyViewer = document.getElementById("storyViewer");
const storyProgress = document.getElementById("storyProgress");
let storyTimer;

async function loadStories() {
  const q = query(collection(db, "stories"), orderBy("createdAt", "asc"));

  onSnapshot(q, async (snap) => {
    if (!storiesList) return;

    storiesList.innerHTML = "";
    const now = Date.now();
    const storiesByUser = {};

    // 1. Group stories by user
    snap.forEach((docSnap) => {
      const story = docSnap.data();
      if (story.expiresAt <= now) return;

      if (!storiesByUser[story.userId]) {
        storiesByUser[story.userId] = [];
      }
      storiesByUser[story.userId].push({
        id: docSnap.id,
        ...story
      });
    });

    allUsersStoryBundles = Object.values(storiesByUser);

    // 2. Create circles using LIVE user data
    for (const userId in storiesByUser) {
      const userStories = storiesByUser[userId];
      
      // Get the latest data for this specific user
      const userDocRef = doc(db, "users", userId);
      const userDocSnap = await getDoc(userDocRef);
      
      let livePfp = 'https://cdn-icons-png.flaticon.com/512/149/149071.png';
      let displayName = userStories[0].user.split('@')[0];

      if (userDocSnap.exists()) {
        const userData = userDocSnap.data();
        // Use the profilePic from the USER document, not the story document
        livePfp = userData.profilePic || livePfp;
        if(userData.username) displayName = userData.username;
      }

      const storyCircle = document.createElement("div");
      storyCircle.className = "story-circle";

      storyCircle.innerHTML = `
        <div class="story-circle-inner">
          <img src="${livePfp}" 
               onerror="this.src='https://cdn-icons-png.flaticon.com/512/149/149071.png'">
        </div>
        <span>${displayName}</span>
      `;

      storyCircle.onclick = () => openStoryTimeline(userStories);
      storiesList.appendChild(storyCircle);
    }
  });
}
function openStoryTimeline(stories) {
  currentStories = stories;
  currentStoryIndex = 0;
  showStory();
}




function showStory() {
  if (!storyViewer || currentStoryIndex >= currentStories.length) {
    closeStoryViewer();
    return;
  }

  const story = currentStories[currentStoryIndex];
  storyViewer.style.display = "flex";

  // 1. üî• MAIN MEDIA (The actual story content)
  // Inside your showStory() function:
const mediaBox = document.getElementById("storyViewMedia");
mediaBox.innerHTML = `
  <img src="${story.image}" alt="story">
`;

  // 2. üî• TOP AVATAR (The small circle in the corner)
  // We use a default avatar link if profilePic is missing to prevent broken images
  const defaultAvatar = "https://cdn-icons-png.flaticon.com/512/149/149071.png";
  const avatarImg = document.getElementById("storyViewAvatar");
  
  avatarImg.src = story.profilePic || defaultAvatar;
  
  // Extra safety: if the image fails to load, swap it with the default
  avatarImg.onerror = function() {
    this.src = defaultAvatar;
  };

  document.getElementById("storyViewUser").innerText = story.user.split('@')[0];

  const storyRef = doc(db, "stories", story.id);

  // üîÅ CLEAN OLD LISTENER
  if (unsubscribeLikes) unsubscribeLikes();

  // ‚ù§Ô∏è LIVE LIKE COUNT
  unsubscribeLikes = onSnapshot(storyRef, (snap) => {
    if (!snap.exists()) return;

    const likes = snap.data().likes || [];
    const likeBtn = document.getElementById("likeStoryBtn");

    document.getElementById("storyLikeCount").innerText = likes.length;

    const isLiked = likes.includes(auth.currentUser.uid);
    likeBtn.style.background = isLiked ? "white" : "rgba(255,255,255,0.1)";
    likeBtn.style.color = isLiked ? "red" : "white";
  });

  // ‚ù§Ô∏è LIKE / UNLIKE Logic
  document.getElementById("likeStoryBtn").onclick = async () => {
    const uid = auth.currentUser.uid;
    try {
      const snap = await getDoc(storyRef);
      if (!snap.exists()) return;
      const likes = snap.data().likes || [];

      if (likes.includes(uid)) {
        await updateDoc(storyRef, { likes: arrayRemove(uid) });
      } else {
        await updateDoc(storyRef, { likes: arrayUnion(uid) });
        if (story.userId !== uid) {
          await addDoc(collection(db, "notifications"), {
            to: story.userId,
            from: auth.currentUser.email.split("@")[0],
            type: "story_like",
            timestamp: serverTimestamp()
          });
        }
      }
    } catch (e) {
      console.error(e);
    }
  };
  // Function for the right arrow (Next)
window.nextStory = () => {
  // 1. Is there another photo for THIS user?
  if (currentStoryIndex < currentStories.length - 1) {
    currentStoryIndex++;
    showStory();
  } 
  else {
    // 2. No more photos for this user. Is there a NEXT user?
    // Find where we are in the big list of users
    const currentUserIndex = allUsersStoryBundles.findIndex(bundle => bundle[0].userId === currentStories[0].userId);
    
    if (currentUserIndex !== -1 && currentUserIndex < allUsersStoryBundles.length - 1) {
      // Jump to the first story of the NEXT user
      openStoryTimeline(allUsersStoryBundles[currentUserIndex + 1]);
    } else {
      // 3. Truly the end of everyone's stories
      closeStoryViewer();
    }
  }
};

// Function for the left arrow (Back)
window.prevStory = () => {
  // 1. Is there a previous photo for THIS user?
  if (currentStoryIndex > 0) {
    currentStoryIndex--;
    showStory();
  } 
  else {
    // 2. No more photos back here. Is there a PREVIOUS user?
    const currentUserIndex = allUsersStoryBundles.findIndex(bundle => bundle[0].userId === currentStories[0].userId);
    
    if (currentUserIndex > 0) {
      // Jump to the PREVIOUS user
      const prevUserStories = allUsersStoryBundles[currentUserIndex - 1];
      
      // IMPORTANT: Set the index to the LAST photo of that user
      currentStories = prevUserStories;
      currentStoryIndex = prevUserStories.length - 1; 
      
      showStory();
    } else {
      // 3. Already at the very first photo of the very first user
      console.log("No more stories to go back to!");
    }
  }
};

  // ‚è± PROGRESS BAR
  clearInterval(storyTimer);
  let progress = 0;
  storyProgress.style.width = "0%";

  storyTimer = setInterval(() => {
    progress += 1;
    storyProgress.style.width = progress + "%";

    if (progress >= 100) {
  clearInterval(storyTimer);
  window.nextStory(); // This ensures the timer also knows how to jump to the next user!
}
  }, 50);
}


function closeStoryViewer() {
  if (storyViewer) storyViewer.style.display = "none";
  clearInterval(storyTimer);
  if (unsubscribeLikes) unsubscribeLikes();
}


const closeStoryBtn = document.getElementById("closeStory");
if (closeStoryBtn) {
  closeStoryBtn.onclick = closeStoryViewer;
}

/* GROUP CHAT */
function loadGroups() {
  const groupsListContainer = document.getElementById("groupsList");
  if (!groupsListContainer) return;

  const q = query(collection(db, "groups"), where("members", "array-contains", auth.currentUser.uid));
  onSnapshot(q, (snap) => {
    groupsListContainer.innerHTML = "";
    snap.forEach((docSnap) => {
      const g = docSnap.data();
      const div = document.createElement("div");
      div.className = "friend-item";
      div.innerHTML = `<span>üë• ${g.name}</span>`;
      div.onclick = () => openGroupChat(docSnap.id, g.name);
      groupsListContainer.appendChild(div);
    });
  });
}

window.openGroupChat = (groupId, groupName) => {
  currentChatFriend = null;
  currentGroupId = groupId;
  
  document.getElementById("messagesBtn").click(); 
  document.getElementById("noChatMessage").style.display = "none";
  document.getElementById("chatContainer").style.display = "flex";
  document.getElementById("chatHeader").innerText = `Group: ${groupName}`;
  
  const q = query(collection(db, "groups", groupId, "messages"), orderBy("createdAt", "asc"));
  onSnapshot(q, (snap) => {
    const chatMessages = document.getElementById("chatMessages");
    chatMessages.innerHTML = "";
    snap.forEach((mDoc) => {
      const msg = mDoc.data();
      const isOwn = msg.sender === auth.currentUser.uid;
      const msgEl = document.createElement("div");
      msgEl.className = `message ${isOwn ? "own" : "other"}`;
      msgEl.innerHTML = `
        <small style="display:block; font-size:9px; opacity:0.6;">${msg.senderEmail}</small>
        ${msg.text}
      `;
      chatMessages.appendChild(msgEl);
    });
    chatMessages.scrollTop = chatMessages.scrollHeight;
  });
};
document.addEventListener("DOMContentLoaded", () => {
  const openPostModal = document.getElementById("openPostModal");
  const closePostModal = document.getElementById("closePostModal");
  const postModal = document.getElementById("postModal");

  openPostModal.onclick = () => {
    postModal.style.display = "flex";
  };

  closePostModal.onclick = () => {
    postModal.style.display = "none";
  };
});
// Function to view another user's profile


window.viewPublicProfile = async (uid) => {
  const publicProfileModal = document.getElementById("publicProfileModal");
  const bioEl = document.getElementById("publicProfileBio");
  const emailEl = document.getElementById("publicProfileEmail");
  const picEl = document.getElementById("publicProfilePic");
  const postsContainer = document.getElementById("publicProfilePosts");

  publicProfileModal.style.display = "flex";
  postsContainer.innerHTML = `
    <div style="display:flex; justify-content:center; padding:20px;">
      <div class="spinner"></div>
    </div>
  `;

  // 1Ô∏è‚É£ USER INFO
  const userDoc = await getDoc(doc(db, "users", uid));
  if (userDoc.exists()) {
    const data = userDoc.data();
    emailEl.innerText = data.email || "Unknown User";
    bioEl.innerText = data.bio || "No bio yet";

    if (data.profilePic) {
      picEl.textContent = "";
      picEl.style.backgroundImage = `url(${data.profilePic})`;
      picEl.style.backgroundSize = "cover";
      picEl.style.backgroundPosition = "center";
    } else {
      picEl.textContent = "üë§";
      picEl.style.backgroundImage = "none";
    }
  }

  // 2Ô∏è‚É£ REAL-TIME POSTS
  const q = query(
    collection(db, "posts"),
    where("userId", "==", uid),
    orderBy("createdAt", "desc")
  );

  onSnapshot(q, (snapshot) => {
  postsContainer.innerHTML = "";
  postsContainer.className = "public-posts-grid";

  if (snapshot.empty) {
    postsContainer.innerHTML =
      "<p style='grid-column:1/-1; text-align:center; opacity:0.6;'>No posts yet</p>";
    return;
  }

  snapshot.forEach((docSnap) => {
    const post = docSnap.data();
    const imageUrl = post.image; // ‚úÖ CORRECT FIELD

    const div = document.createElement("div");
    div.className = "profile-post";

    div.innerHTML = `
      <div class="profile-post-text">
        ${post.text || "Tap to view image"}
      </div>

      <div class="profile-post-img">
        <img src="${imageUrl}" loading="lazy">
      </div>
    `;

    div.addEventListener("click", () => {
      div.classList.toggle("show-image");
    });

    postsContainer.appendChild(div);
  });
});
document.addEventListener("click", (e) => {
  if (e.target.id === "closePublicProfile") {
    document.getElementById("publicProfileModal").style.display = "none";
  }
});




};




</script>

</body>
</html>

